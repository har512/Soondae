<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>슬기로운 순대생활 분석기</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pretendard@1.3.8/dist/web/static/pretendard.css">
    <style>
        body { font-family: 'Pretendard', sans-serif; }
        /* 간단한 애니메이션 효과 */
        .result-item {
            opacity: 0;
            transform: translateY(10px);
            animation: fadeIn 0.5s ease-out forwards;
        }
        @keyframes fadeIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .summary-content {
            white-space: pre-wrap; /* 줄바꿈을 인식하도록 설정 */
            word-break: keep-all;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">
    <div class="bg-white p-8 rounded-xl shadow-lg w-full max-w-lg text-center">
        <h1 class="text-2xl font-bold mb-2 text-gray-800">슬기로운 순대생활 분석기</h1>
        <p class="text-gray-500 mb-6">내보내기한 카카오톡 대화(.txt) 파일을 분석합니다.</p>
        
        <label for="fileInput" class="w-full cursor-pointer bg-yellow-300 text-gray-900 font-bold py-3 px-4 rounded-lg hover:bg-yellow-400 transition-colors duration-300 inline-block">
            📂 파일 선택하기
        </label>
        <input type="file" id="fileInput" accept=".txt" class="hidden">
        <p id="fileName" class="text-sm text-gray-600 mt-3 h-5"></p>

        <!-- API 키 입력 섹션 -->
        <div class="mt-6 text-left border-t pt-4">
            <label for="apiKeyInput" class="block text-sm font-medium text-gray-700 mb-1">Gemini API Key</label>
            <div class="relative">
                <input type="password" id="apiKeyInput" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 pr-10" placeholder="API 키를 입력하고 저장하세요">
                <button id="toggleApiKey" type="button" class="absolute inset-y-0 right-0 px-3 flex items-center text-gray-500 hover:text-gray-700">
                    <svg id="eye-icon-open" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye" viewBox="0 0 16 16">
                        <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.816 1.201-2.085 2.224-3.655 2.893C9.879 11.832 8.12 12.5 6 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.133 13.133 0 0 1 1.172 8z"/>
                        <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
                    </svg>
                    <svg id="eye-icon-closed" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye-slash hidden" viewBox="0 0 16 16">
                        <path d="M13.359 11.238C15.06 9.72 16 8 16 8s-3-5.5-8-5.5a7.028 7.028 0 0 0-2.79.588l.77.771A5.94 5.94 0 0 1 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.134 13.134 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755-.165.165-.337.328-.517.486l.708.709z"/>
                        <path d="M11.297 9.176a3.5 3.5 0 0 0-4.474-4.474l.823.823a2.5 2.5 0 0 1 2.829 2.829l.822.822zm-2.943 1.288.822.822.084.083a3.5 3.5 0 0 1-4.474-4.474l.823.823.084.083a2.5 2.5 0 0 0 2.829 2.829z"/>
                        <path d="M3.35 5.47c-.18.16-.353.322-.518.487A13.134 13.134 0 0 0 1.172 8l.195.288c.335.48.83 1.12 1.465 1.755C4.121 11.332 5.881 12.5 8 12.5c.716 0 1.39-.133 2.02-.36l.77.772A7.029 7.029 0 0 1 8 13.5C3 13.5 0 8 0 8s.939-1.721 2.641-3.238l.708.709zm10.296 6.854-12-12 .708-.708 12 12-.708.708z"/>
                    </svg>
                </button>
            </div>
            <button id="saveApiKeyBtn" class="w-full mt-2 bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-700 transition-colors">
                API 키 저장
            </button>
        </div>

        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mt-4">
            <button id="analyzeDailyBtn" class="w-full bg-blue-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-blue-700 transition-colors duration-300 disabled:bg-gray-300 disabled:cursor-not-allowed" disabled>
                오늘의 브리핑
            </button>
            <button id="analyzeWeeklyBtn" class="w-full bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-indigo-700 transition-colors duration-300 disabled:bg-gray-300 disabled:cursor-not-allowed" disabled>
                지난 7일간 순위
            </button>
            <button id="analyzeMonthlyStatusBtn" class="w-full bg-red-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-red-700 transition-colors duration-300 disabled:bg-gray-300 disabled:cursor-not-allowed" disabled>
                더 친해져요
            </button>
            <button id="downloadBtn" class="w-full bg-gray-800 text-white font-bold py-3 px-4 rounded-lg hover:bg-gray-900 transition-colors duration-300 disabled:bg-gray-300 disabled:cursor-not-allowed" disabled>
                CSV 다운로드
            </button>
        </div>
        
        <div id="message" class="mt-4 text-sm h-5"></div>

        <!-- 개인 리포트 섹션 -->
        <div class="mt-6 text-left border-t pt-4">
            <div class="flex flex-col sm:flex-row gap-2">
                <input type="text" id="userInput" class="w-full sm:flex-grow p-2 border border-gray-300 rounded-lg focus:ring-pink-500 focus:border-pink-500" placeholder="닉네임 입력">
                <button id="personalReportBtn" class="w-full sm:w-auto bg-pink-300 text-white font-bold py-2 px-4 rounded-lg hover:bg-pink-400 disabled:bg-gray-300 disabled:cursor-not-allowed whitespace-nowrap">이사람이 궁금해</button>
            </div>
            <p id="userSearchFeedback" class="text-sm text-gray-600 mt-1 h-5"></p>
        </div>

        <!-- 분석 결과가 표시될 영역 -->
        <div id="analysisResult" class="mt-6 text-left"></div>
    </div>

    <script>
        // --- 전역 변수 ---
        let parsedChatData = [];
        let csvContent = '';

        // --- DOM 요소 ---
        const fileInput = document.getElementById('fileInput');
        const downloadBtn = document.getElementById('downloadBtn');
        const analyzeDailyBtn = document.getElementById('analyzeDailyBtn');
        const analyzeWeeklyBtn = document.getElementById('analyzeWeeklyBtn');
        const analyzeMonthlyStatusBtn = document.getElementById('analyzeMonthlyStatusBtn');
        const fileNameEl = document.getElementById('fileName');
        const messageEl = document.getElementById('message');
        const analysisResultEl = document.getElementById('analysisResult');
        const apiKeyInput = document.getElementById('apiKeyInput');
        const saveApiKeyBtn = document.getElementById('saveApiKeyBtn');
        const toggleApiKeyBtn = document.getElementById('toggleApiKey');
        const eyeOpenIcon = document.getElementById('eye-icon-open');
        const eyeClosedIcon = document.getElementById('eye-icon-closed');
        const userInput = document.getElementById('userInput');
        const personalReportBtn = document.getElementById('personalReportBtn');
        const userSearchFeedback = document.getElementById('userSearchFeedback');

        // --- 초기화 ---
        document.addEventListener('DOMContentLoaded', loadApiKey);

        // --- 이벤트 리스너 ---
        fileInput.addEventListener('change', handleFileSelect);
        downloadBtn.addEventListener('click', handleDownload);
        analyzeDailyBtn.addEventListener('click', handleDailyBriefing);
        analyzeWeeklyBtn.addEventListener('click', handleWeeklyAnalysis);
        analyzeMonthlyStatusBtn.addEventListener('click', handleMonthlyStatus);
        saveApiKeyBtn.addEventListener('click', saveApiKey);
        toggleApiKeyBtn.addEventListener('click', toggleApiKeyVisibility);
        personalReportBtn.addEventListener('click', handlePersonalReport);

        // --- 함수 정의 ---

        function loadApiKey() {
            const savedKey = localStorage.getItem('geminiApiKey');
            if (savedKey) {
                apiKeyInput.value = savedKey;
            }
        }

        function saveApiKey() {
            const key = apiKeyInput.value.trim();
            if (key) {
                localStorage.setItem('geminiApiKey', key);
                messageEl.textContent = '✅ API 키가 브라우저에 저장되었습니다.';
                messageEl.className = 'mt-4 text-sm h-5 text-green-600';
            } else {
                localStorage.removeItem('geminiApiKey');
                messageEl.textContent = '⚠️ API 키가 비어있어 저장되지 않았습니다.';
                messageEl.className = 'mt-4 text-sm h-5 text-red-600';
            }
        }

        function toggleApiKeyVisibility() {
            const isPassword = apiKeyInput.type === 'password';
            apiKeyInput.type = isPassword ? 'text' : 'password';
            eyeOpenIcon.classList.toggle('hidden', isPassword);
            eyeClosedIcon.classList.toggle('hidden', !isPassword);
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) {
                resetUI();
                return;
            }
            fileNameEl.textContent = file.name;
            resetUI(false);
            messageEl.textContent = '파일을 읽는 중...';
            messageEl.className = 'mt-4 text-sm h-5 text-blue-600';
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    let fullChatData = parseKakaoTalkLogExcelSafe(e.target.result);
                    
                    const sevenDaysAgo = new Date();
                    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
                    sevenDaysAgo.setHours(0, 0, 0, 0);
                    
                    parsedChatData = fullChatData.filter(chat => new Date(chat.Timestamp) >= sevenDaysAgo);

                    if (parsedChatData.length > 0) {
                        csvContent = convertToCSV(parsedChatData);
                        downloadBtn.disabled = false;
                        analyzeDailyBtn.disabled = false;
                        analyzeWeeklyBtn.disabled = false;
                        analyzeMonthlyStatusBtn.disabled = false;
                        personalReportBtn.disabled = false;
                        messageEl.textContent = `🎉 최근 7일간 ${parsedChatData.length}개 메시지 처리 완료!`;
                        messageEl.className = 'mt-4 text-sm h-5 text-green-600';
                    } else {
                        throw new Error("최근 7일간의 대화 기록이 없습니다.");
                    }
                } catch (err) {
                    resetUI(false);
                    messageEl.textContent = `⚠️ 오류: ${err.message}`;
                    messageEl.className = 'mt-4 text-sm h-5 text-red-600';
                }
            };
            reader.onerror = () => {
                resetUI();
                messageEl.textContent = '⚠️ 파일을 읽는 데 실패했습니다.';
                messageEl.className = 'mt-4 text-sm h-5 text-red-600';
            };
            reader.readAsText(file, 'UTF-8');
        }
        
        async function handlePersonalReport() {
            const searchTerm = userInput.value.trim();
            if (!searchTerm) {
                userSearchFeedback.textContent = '닉네임을 입력해주세요.';
                return;
            }

            const allUsers = [...new Set(parsedChatData.map(chat => chat.User).filter(user => user !== '시스템' && user !== '관리자'))];
            const matchedUsers = allUsers.filter(user => user.startsWith(searchTerm));

            if (matchedUsers.length === 0) {
                userSearchFeedback.textContent = '해당하는 사용자를 찾을 수 없습니다.';
                analysisResultEl.innerHTML = '';
                return;
            }
            if (matchedUsers.length > 1) {
                userSearchFeedback.textContent = '여러 명이 검색됩니다. 더 정확하게 입력해주세요.';
                analysisResultEl.innerHTML = '';
                return;
            }

            const targetUser = matchedUsers[0];
            userSearchFeedback.textContent = `✅ '${targetUser}' 님의 리포트를 생성합니다...`;
            analysisResultEl.innerHTML = '<p class="text-center">리포트 생성 중... 🤖</p>';

            const userMessages = parsedChatData.filter(chat => chat.User === targetUser);
            
            const responders = {};
            for (let i = 0; i < parsedChatData.length; i++) {
                if (parsedChatData[i].User === targetUser) {
                    // 다음 3개의 메시지를 확인
                    for (let j = 1; j <= 3; j++) {
                        if (i + j < parsedChatData.length) {
                            const nextChat = parsedChatData[i + j];
                            if (nextChat.User !== targetUser && nextChat.User !== '시스템' && nextChat.User !== '관리자') {
                                responders[nextChat.User] = (responders[nextChat.User] || 0) + 1;
                                break; // 한 번의 반응만 카운트
                            }
                        }
                    }
                }
            }
            const topResponders = Object.entries(responders).sort((a, b) => b[1] - a[1]).slice(0, 3).map(item => item[0]);

            try {
                const report = await generatePersonalReport(targetUser, userMessages, topResponders);
                displayPersonalReport(targetUser, report);
            } catch (error) {
                analysisResultEl.innerHTML = `<p class="text-red-500">${error.message}</p>`;
            }
        }

        async function generatePersonalReport(targetUser, userMessages, topResponders) {
            const apiKey = apiKeyInput.value.trim() || localStorage.getItem('geminiApiKey');
            if (!apiKey) {
                throw new Error("Gemini API 키를 입력하고 저장해주세요.");
            }

            const prompt = `
                '${targetUser}' 님의 최근 7일간 카카오톡 대화 기록을 분석해서 아래 형식에 맞춰 리포트를 작성해줘.
                
                **분석할 내용:**
                1. 총 대화 횟수: ${userMessages.length}회
                2. 주요 대화 주제: 아래 대화 내용을 바탕으로 핵심 주제를 3가지 정도로 재미있게 요약해줘.
                3. 소울메이트 분석: 이 사람의 말에 가장 많이 반응한 상위 3명은 다음과 같아: ${topResponders.join(', ')}. 이 사실을 바탕으로 상호작용에 대해 재밌있게 코멘트해줘.

                **참고 대화 내용:**
                ---
                ${userMessages.map(m => m.Message).join('\n').substring(0, 4000)}
                ---

                **출력 형식 (반드시 이 형식에 맞춰서 작성):**
                ### 💬 총 대화 횟수
                - 총 ${userMessages.length}회 대화에 참여했어요.

                ### 📜 주요 대화 주제
                - [주제 1 요약]
                - [주제 2 요약]
                - [주제 3 요약]

                ### 🙋‍♂️ 친한친구 분석
                - [상호작용에 대한 재미있는 코멘트]
            `;

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            const payload = { contents: [{ parts: [{ text: prompt }] }] };
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!response.ok) throw new Error(`API 호출 실패: ${response.status}`);
            const result = await response.json();
            if (result.candidates && result.candidates.length > 0) {
                return result.candidates[0].content.parts[0].text;
            } else {
                throw new Error("API 응답 형식이 올바르지 않습니다.");
            }
        }

        function displayPersonalReport(targetUser, report) {
            analysisResultEl.innerHTML = '';
            const title = document.createElement('h2');
            title.className = 'text-xl font-bold mb-3 text-gray-800 border-b pb-2';
            title.textContent = `📊 ${targetUser}님 개인 리포트`;
            
            const content = document.createElement('div');
            content.className = 'summary-content text-left';
            content.innerHTML = report.replace(/### (.*)/g, '<h3 class="text-lg font-bold mt-4 mb-2 text-gray-700">$1</h3>')
                                      .replace(/^- (.*)/gm, '<p class="ml-2">- $1</p>');
            
            analysisResultEl.appendChild(title);
            analysisResultEl.appendChild(content);
        }

        async function handleDailyBriefing() {
            if (parsedChatData.length === 0) return;
            
            let chatsForRanking = [];
            let analysisDate = null;

            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const todaysChats = parsedChatData.filter(chat => {
                const chatDate = new Date(chat.Timestamp);
                chatDate.setHours(0, 0, 0, 0);
                return chatDate.getTime() === today.getTime();
            });

            if (todaysChats.length > 0) {
                chatsForRanking = todaysChats;
                analysisDate = today;
            } else {
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                yesterday.setHours(0, 0, 0, 0);
                const yesterdaysChats = parsedChatData.filter(chat => {
                    const chatDate = new Date(chat.Timestamp);
                    chatDate.setHours(0, 0, 0, 0);
                    return chatDate.getTime() === yesterday.getTime();
                });
                if (yesterdaysChats.length > 0) {
                    chatsForRanking = yesterdaysChats;
                    analysisDate = yesterday;
                }
            }

            if (chatsForRanking.length === 0) {
                displayAnalysisResult([], '오늘과 어제');
                return;
            }

            const userCounts = countUserMessages(chatsForRanking);
            const top5 = getTopUsers(userCounts);

            displayAnalysisResult(top5, null, true, analysisDate);
            displayMemberChanges(chatsForRanking);

            const twentyFourHoursAgo = new Date();
            twentyFourHoursAgo.setHours(twentyFourHoursAgo.getHours() - 24);
            const last24hChats = parsedChatData.filter(chat => new Date(chat.Timestamp) >= twentyFourHoursAgo);

            for (const [user, count] of top5) {
                const userChats = last24hChats
                    .filter(chat => chat.User === user)
                    .map(chat => chat.Message)
                    .join('\n');
                
                const summaryElement = document.getElementById(`summary-for-${user.replace(/\s/g, '-')}`);
                if (summaryElement) {
                    if (userChats.length > 0) {
                        try {
                            const summary = await generateSummary(user, userChats);
                            summaryElement.innerHTML = `<p class="summary-content">${summary}</p>`;
                        } catch (error) {
                            summaryElement.innerHTML = `<p class="text-red-500">${error.message}</p>`;
                        }
                    } else {
                        summaryElement.innerHTML = `<p class="text-gray-500">지난 24시간 대화 없음</p>`;
                    }
                }
            }
        }

        async function generateSummary(userName, userChats) {
            const apiKey = apiKeyInput.value.trim() || localStorage.getItem('geminiApiKey');
            if (!apiKey) {
                throw new Error("Gemini API 키를 입력하고 저장해주세요.");
            }
            
            const prompt = `${userName}님의 최근 대화 내용입니다. 이 내용을 바탕으로 이사람의 주요관심사와 대화주제가 뭐였는지 이모티콘을 섞어서 친구에게 말하듯 위트있게 3줄 이내로 요약해주세요:\n\n---\n${userChats.substring(0, 3000)}\n---`;
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            
            const payload = { contents: [{ parts: [{ text: prompt }] }] };

            let retries = 3;
            let delay = 1000;
            while (retries > 0) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (!response.ok) {
                        throw new Error(`API 호출 실패: ${response.status}`);
                    }
                    const result = await response.json();
                    if (result.candidates && result.candidates.length > 0) {
                        return result.candidates[0].content.parts[0].text;
                    } else {
                        throw new Error("API 응답 형식이 올바르지 않습니다.");
                    }
                } catch (error) {
                    retries--;
                    if (retries === 0) {
                        console.error("API call failed after multiple retries:", error);
                        throw new Error("요약 생성에 실패했어요 😢");
                    }
                    await new Promise(res => setTimeout(res, delay));
                    delay *= 2;
                }
            }
        }

        function handleWeeklyAnalysis() {
            if (parsedChatData.length === 0) return;
            const userCounts = countUserMessages(parsedChatData);
            const top20 = getTopUsers(userCounts, 20);
            displayAnalysisResult(top20, '지난 7일간');
        }

        function handleMonthlyStatus() {
            if (parsedChatData.length === 0) return;
            const now = new Date();
            const monthlyChats = parsedChatData.filter(chat => {
                const chatDate = new Date(chat.Timestamp);
                return chatDate.getFullYear() === now.getFullYear() && chatDate.getMonth() === now.getMonth();
            });
            if (monthlyChats.length === 0) {
                displayWarningList([], '이번 달');
                return;
            }
            const userCounts = countUserMessages(monthlyChats);
            const warningUsers = Object.entries(userCounts)
                .filter(([user, count]) => count < 50)
                .sort((a, b) => a[1] - b[1]);
            displayWarningList(warningUsers, '이번 달');
        }
        
        function countUserMessages(chatList) {
            const userCounts = {};
            chatList.forEach(chat => {
                if (chat.User !== '시스템' && chat.User !== '관리자') {
                    userCounts[chat.User] = (userCounts[chat.User] || 0) + 1;
                }
            });
            return userCounts;
        }

        function getTopUsers(userCounts, count = 5) {
            return Object.entries(userCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, count);
        }
        
        function formatDate(date) {
            const year = date.getFullYear().toString().slice(-2);
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = date.getDate().toString().padStart(2, '0');
            const dayOfWeek = ['일', '월', '화', '수', '목', '금', '토'][date.getDay()];
            return `${year}.${month}.${day} (${dayOfWeek})`;
        }

        function displayAnalysisResult(ranking, dateString, isBriefing = false, briefingDate = null) {
            analysisResultEl.innerHTML = '';
            
            let titleText = '';
            if (isBriefing && briefingDate) {
                titleText = `오늘의 순대 브리핑 (${formatDate(briefingDate)})`;
            } else {
                titleText = `👑 ${dateString}의 대화왕 순위 TOP ${ranking.length}`;
            }

            const title = document.createElement('h2');
            title.className = 'text-xl font-bold mb-3 text-gray-800 border-b pb-2';
            title.textContent = titleText;
            analysisResultEl.appendChild(title);

            if (ranking.length === 0) {
                const noData = document.createElement('p');
                noData.className = 'text-gray-500 mt-4';
                noData.textContent = `${dateString} 대화 기록이 없습니다.`;
                analysisResultEl.appendChild(noData);
                return;
            }
            const list = document.createElement('ol');
            list.className = 'space-y-3';
            const medals = ['🥇', '🥈', '🥉'];
            ranking.forEach(([user, count], index) => {
                const item = document.createElement('li');
                item.className = 'result-item p-3 rounded-lg bg-gray-50 text-left';
                item.style.animationDelay = `${index * 100}ms`;
                const rank = medals[index] || `${index + 1}.`;
                const summaryHtml = isBriefing ?
                    `<div id="summary-for-${user.replace(/\s/g, '-')}" class="mt-2 text-sm text-gray-600 p-2 bg-gray-100 rounded">요약 중... 🤔</div>` : '';
                
                item.innerHTML = `
                    <div class="flex items-center justify-between">
                        <div class="flex items-center">
                            <span class="font-bold w-8 text-lg">${rank}</span>
                            <span class="text-gray-700">${user}</span>
                        </div>
                        <span class="font-semibold text-blue-600">${count}회</span>
                    </div>
                    ${summaryHtml}
                `;
                list.appendChild(item);
            });
            analysisResultEl.appendChild(list);
        }

        function displayMemberChanges(chatList) {
            const newMembers = [];
            const leftMembers = [];

            const systemMessages = chatList.filter(chat => chat.User === '시스템');
            systemMessages.forEach(chat => {
                if (chat.Message.includes('님이 들어왔습니다')) {
                    newMembers.push(chat.Message.split('님이 들어왔습니다')[0]);
                } else if (chat.Message.includes('님이 나갔습니다')) {
                    leftMembers.push(chat.Message.split('님이 나갔습니다')[0]);
                }
            });

            const noticeSection = document.createElement('div');
            noticeSection.id = 'notice-section';
            noticeSection.className = 'mt-6 pt-4 border-t';
            
            const title = document.createElement('h3');
            title.className = 'text-lg font-bold mb-2 text-gray-700';
            title.textContent = '🏠 순대 동사무소 알림';
            noticeSection.appendChild(title);

            if (newMembers.length === 0 && leftMembers.length === 0) {
                noticeSection.innerHTML += `<p class="text-gray-500 text-sm">오늘은 인원 변동이 없어요!</p>`;
            } else {
                if (newMembers.length > 0) {
                    noticeSection.innerHTML += `<p class="text-green-600 text-sm">🎉 ${newMembers.join(', ')} 님이 새로 전입왔어요!</p>`;
                }
                if (leftMembers.length > 0) {
                    noticeSection.innerHTML += `<p class="text-red-600 text-sm">😢 ${leftMembers.join(', ')} 님이 전출가셨어요.</p>`;
                }
            }
            
            const shareButtonContainer = document.createElement('div');
            shareButtonContainer.className = 'mt-6 text-center';
            const shareButton = document.createElement('button');
            shareButton.id = 'shareBriefingBtn';
            shareButton.className = 'bg-green-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-600 transition-colors';
            shareButton.textContent = '브리핑 내용 공유하기';
            shareButton.onclick = handleShareBriefing;
            shareButtonContainer.appendChild(shareButton);

            analysisResultEl.appendChild(noticeSection);
            analysisResultEl.appendChild(shareButtonContainer);
        }
        
        function handleShareBriefing() {
            const briefingContent = [];
            
            const title = analysisResultEl.querySelector('h2').textContent;
            briefingContent.push(`[${title}]`);
            
            const rankingList = analysisResultEl.querySelectorAll('ol > li');
            rankingList.forEach(item => {
                const rank = item.querySelector('.font-bold').textContent;
                const user = item.querySelector('.text-gray-700').textContent;
                const count = item.querySelector('.font-semibold').textContent;
                const summary = item.querySelector('.summary-content')?.textContent || '(요약 없음)';
                
                briefingContent.push(`\n${rank} ${user} (${count})`);
                briefingContent.push(`${summary}`);
            });

            const noticeSection = analysisResultEl.querySelector('#notice-section');
            if (noticeSection) {
                const noticeTitle = noticeSection.querySelector('h3')?.textContent;
                briefingContent.push('\n---');
                briefingContent.push(`[${noticeTitle}]`);
                const notices = noticeSection.querySelectorAll('p');
                notices.forEach(p => {
                    briefingContent.push(p.textContent);
                });
            }

            const textToCopy = briefingContent.join('\n');
            
            const textArea = document.createElement("textarea");
            textArea.value = textToCopy;
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                document.execCommand('copy');
                messageEl.textContent = '✅ 브리핑 내용이 복사되었습니다!';
                messageEl.className = 'mt-4 text-sm h-5 text-green-600';
            } catch (err) {
                messageEl.textContent = '⚠️ 복사에 실패했습니다.';
                messageEl.className = 'mt-4 text-sm h-5 text-red-600';
            }
            document.body.removeChild(textArea);
        }


        function displayWarningList(warningList, dateString) {
            analysisResultEl.innerHTML = '';
            const title = document.createElement('h2');
            title.className = 'text-xl font-bold mb-3 text-red-600 border-b pb-2';
            title.textContent = `☕️ 더 친해져요 (${dateString} 50회 미만)`;
            analysisResultEl.appendChild(title);
            if (warningList.length === 0) {
                const allActive = document.createElement('p');
                allActive.className = 'text-gray-500 mt-4';
                allActive.textContent = `모든 멤버가 50회 이상 대화했습니다. 훌륭해요!`;
                analysisResultEl.appendChild(allActive);
                return;
            }
            const list = document.createElement('ul');
            list.className = 'space-y-2';
            warningList.forEach(([user, count], index) => {
                const item = document.createElement('li');
                item.className = 'result-item flex items-center justify-between p-2 rounded-lg bg-red-50';
                item.style.animationDelay = `${index * 100}ms`;
                item.innerHTML = `
                    <span class="text-gray-700">${user}</span>
                    <span class="font-semibold text-red-600">${count}회</span>
                `;
                list.appendChild(item);
            });
            analysisResultEl.appendChild(list);
        }

        function handleDownload() {
            if (!csvContent || downloadBtn.disabled) return;
            const blob = new Blob(['\uFEFF' + csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', 'KakaoTalk_chat_log.csv');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        function resetUI(resetFileName = true) {
            if (resetFileName) {
                fileNameEl.textContent = '';
                fileInput.value = '';
            }
            downloadBtn.disabled = true;
            analyzeDailyBtn.disabled = true;
            analyzeWeeklyBtn.disabled = true;
            analyzeMonthlyStatusBtn.disabled = true;
            personalReportBtn.disabled = true;
            messageEl.textContent = '';
            analysisResultEl.innerHTML = '';
            parsedChatData = [];
            csvContent = '';
        }

        function parseKakaoTalkLogExcelSafe(fileContent) {
            const chatData = [];
            if (!fileContent) return chatData;
            const chatPattern = /^(\d{4}년 \d{1,2}월 \d{1,2}일) (오전|오후) (\d{1,2}:\d{2}),\s*(.*?)\s*:\s*(.*)/;
            const systemPattern = /^(\d{4}년 \d{1,2}월 \d{1,2}일) (오전|오후) (\d{1,2}:\d{2}),\s*(.*(?:님이 들어왔습니다|님을 내보냈습니다|님이 나갔습니다)\.?)/;
            const adminPattern = /^(\d{4}년 \d{1,2}월 \d{1,2}일) (오전|오후) (\d{1,2}:\d{2}),\s*(관리자가 \d+개의 메시지를 가렸습니다\.)/;
            const dateSeparatorPattern = /^-+\s*\d{4}년 \d{1,2}월 \d{1,2}일\s.*-+$/;
            const timestampOnlyPattern = /^\d{4}년 \d{1,2}월 \d{1,2}일 (오전|오후) \d{1,2}:\d{2}$/;
            let currentMessageInfo = null;
            const lines = fileContent.split('\n');
            const formatTimestamp = (dateStr, amPmStr, timeStr) => {
                const datePart = dateStr.match(/(\d{4})년 (\d{1,2})월 (\d{1,2})일/);
                const year = parseInt(datePart[1], 10);
                const month = parseInt(datePart[2], 10) - 1;
                const day = parseInt(datePart[3], 10);
                let [hour, minute] = timeStr.split(':').map(num => parseInt(num, 10));
                if (amPmStr === '오후' && hour !== 12) hour += 12;
                if (amPmStr === '오전' && hour === 12) hour = 0;
                return new Date(year, month, day, hour, minute);
            };
            const excelSafeText = (text) => {
                if (/^\d{1,2}[/-]\d{1,2}$/.test(text) || /^\d{1,2}-\d{1,2}$/.test(text)) return "'" + text;
                return text;
            };
            for (const line of lines) {
                const trimmedLine = line.trim();
                if (!trimmedLine) continue;
                const adminMatch = trimmedLine.match(adminPattern);
                const systemMatch = trimmedLine.match(systemPattern);
                const chatMatch = trimmedLine.match(chatPattern);
                const isNewMessageLine = adminMatch || systemMatch || chatMatch;
                const isIgnorableLine = dateSeparatorPattern.test(trimmedLine) || timestampOnlyPattern.test(trimmedLine);
                if (isNewMessageLine) {
                    if (currentMessageInfo) chatData.push(currentMessageInfo);
                    currentMessageInfo = null;
                    if (adminMatch) {
                        const [, date, amPm, time, message] = adminMatch;
                        const timestamp = formatTimestamp(date, amPm, time);
                        chatData.push({ Timestamp: timestamp, User: '관리자', Message: message });
                    } else if (systemMatch) {
                        const [, date, amPm, time, message] = systemMatch;
                        const timestamp = formatTimestamp(date, amPm, time);
                        chatData.push({ Timestamp: timestamp, User: '시스템', Message: message });
                    } else if (chatMatch) {
                        const [, date, amPm, time, user, message] = chatMatch;
                        const timestamp = formatTimestamp(date, amPm, time);
                        const safeMessage = excelSafeText(message);
                        currentMessageInfo = { Timestamp: timestamp, User: user, Message: safeMessage };
                    }
                } else if (!isIgnorableLine && currentMessageInfo) {
                    currentMessageInfo.Message += '\n' + trimmedLine;
                }
            }
            if (currentMessageInfo) chatData.push(currentMessageInfo);
            return chatData;
        }
        
        function convertToCSV(data) {
            if (!data || data.length === 0) return "";
            const headers = Object.keys(data[0]);
            const csvRows = [headers.join(',')];
            for (const row of data) {
                const values = headers.map(header => {
                    let cell = row[header];
                    if (cell instanceof Date) cell = cell.toISOString();
                    if (typeof cell === 'string' && (cell.includes(',') || cell.includes('\n') || cell.includes('"'))) {
                        cell = `"${cell.replace(/"/g, '""')}"`;
                    }
                    return cell;
                });
                csvRows.push(values.join(','));
            }
            return csvRows.join('\n');
        }
    </script>
</body>
</html>
"이사람이 궁금해"를 "마음을 알아봐줘"로 
